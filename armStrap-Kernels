#!/usr/bin/env python3

import argparse
import atexit
import builtins
import configparser
import crypt
import locale
import syslog
import logging
import os
import sys
import subprocess
import collections 
import re
import shutil
import glob
import time

from logging.handlers import SysLogHandler

def writeLog(str):
  logging.warning(str)

# Check if a file exist
def checkFile(file):   
  try:
    if os.path.isfile(file):
      writeLog(file + " exist")
      return True
    else:
      writeLog(file + " does not exist")
      return False
  except SystemExit:
    pass
  except:
    logging.exception("Caught Exception")
    sys.exit(os.EX_SOFTWARE)

# Check if a directory exist
def checkDirectory(Directory):
  try:
    if os.path.exists(Directory):
      if os.path.isdir(Directory):
        return(True)
    return(False)
  except SystemExit:
    pass
  except:
    logging.exception("Caught Exception")
    sys.exit(os.EX_SOFTWARE)

# Create a directory.
def makeDirectory(Directory):
  try:
    if Directory:
      if not checkDirectory(Directory):
         os.makedirs(Directory)
      return(True)
    return(False)
  except SystemExit:
    pass
  except:
    logging.exception("Caught Exception")
    sys.exit(os.EX_SOFTWARE)

    
# Read a config file
def readConfig(configFile):
  try:
    if checkFile(configFile):
      writeLog("Reading configuration file " + configFile)
      config = configparser.ConfigParser()
      config.sections()
      config.read(configFile)
    else:
      writeLog("Configuration file " + configFile + " does not exist")
      config = False
    return config
  except SystemExit:
    pass
  except:
    logging.exception("Caught Exception")
    sys.exit(os.EX_SOFTWARE)

# List all kernels configuration.
def showKernels(Kernels):
  try:
    print('{:<8} {:<8} {:<70} {:<16}'.format("Type", "CPU", "Git-URL", "Branch"));
    print('{:-^8} {:-^8} {:-^70} {:-^16}'.format("", "", "", ""));
    for Kernel in Kernels.sections():  
      print('{:<8} {:<8} {:<70} {:<16}'.format(Kernels[Kernel]['type'], Kernels[Kernel]['cpu'], Kernels[Kernel]['git'], Kernels[Kernel]['branch']))
  except SystemExit:
    pass
  except:
    logging.exception("Caught Exception")
    sys.exit(os.EX_SOFTWARE)

# Update from Git repository.
def gitUpdate(Kernels, Kernel):
  try:
    if checkDirectory(builtins.SrcDir + "/" + Kernels[Kernel]['type']):
      print("Updating sources for kernel " + Kernel + " (" + Kernels[Kernel]['type'] + ")")
      return(runCommand("(cd " + builtins.SrcDir + "/" + Kernels[Kernel]['type'] + " && /usr/bin/git pull)"))
    return [1, "Directory not found"]
  except SystemExit:
    pass
  except:
    logging.exception("Caught Exception")
    sys.exit(os.EX_SOFTWARE)

# Switch repository branch.
def gitBranch(Kernels, Kernel):
  try:
    if checkDirectory(builtins.SrcDir + "/" + Kernels[Kernel]['type']):
      print("Checking out branch " + Kernels[Kernel]['branch'] + " for kernel " + Kernel + " (" + Kernels[Kernel]['type'] + ")")
      return(runCommand("(cd " + builtins.SrcDir + "/" + Kernels[Kernel]['type'] + " && /usr/bin/git checkout " + Kernels[Kernel]['branch'] + ")"))
    return [1, "Directory not found"]
  except SystemExit:
    pass
  except:
    logging.exception("Caught Exception")
    sys.exit(os.EX_SOFTWARE)
    
# Reset to last commit.
def gitReset(Kernels, Kernel):
  try:
    if checkDirectory(builtins.SrcDir + "/" + Kernels[Kernel]['type']):
      print("Resetting sources for kernel " + Kernel + " (" + Kernels[Kernel]['type'] + ")")
      return(runCommand("(cd " + builtins.SrcDir + "/" + Kernels[Kernel]['type'] + " && /usr/bin/git fetch origin && /usr/bin/git reset --hard origin/" + Kernels[Kernel]['branch'] + " && /usr/bin/git clean -f -x -d)"))
    return [1, "Directory not found"]
  except SystemExit:
    pass
  except:
    logging.exception("Caught Exception")
    sys.exit(os.EX_SOFTWARE)

# Clone a repository.    
def gitClone(Kernels, Kernel):
  try:
    if not checkDirectory(builtins.SrcDir + "/" + Kernels[Kernel]['type']):
      print("Cloning sources for kernel " + Kernel + " (" + Kernels[Kernel]['type'] + ")")
      print("/usr/bin/git clone " + Kernels[Kernel]['git'] + " " + builtins.SrcDir + "/" + Kernels[Kernel]['type'])
      return(runCommand("/usr/bin/git clone " + Kernels[Kernel]['git'] + " " + builtins.SrcDir + "/" + Kernels[Kernel]['type']))
    return [0, ""]
  except SystemExit:
    pass
  except:
    logging.exception("Caught Exception")
    sys.exit(os.EX_SOFTWARE)

# Return the system type.    
def systemType():
  try:
    st = runCommand("/bin/uname -p")
    if st[0] == 0:
      return(st[1].splitlines()[0])
    return(False)
  except SystemExit:
    pass
  except:
    logging.exception("Caught Exception")
    sys.exit(os.EX_SOFTWARE)

# Exeute an external command, capturing its output.
def runCommand(Command, verbose = True):
  try:
    p = subprocess.Popen(Command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True, bufsize=1, shell=True)
    log = ""
    while(True):
      retcode = p.poll()
      line = p.stdout.readline()
      log = log + line
      if verbose:
        sys.stdout.write(line)
      if retcode is not None:
        break
    return [retcode, log]
  except subprocess.CalledProcessError as e:
    return [e.returncode, e.output]
  except SystemExit:  
    pass
  except:
    logging.exception("Caught Exception")
    sys.exit(os.EX_SOFTWARE)

# Execute a make command in an arm build ready environment
def makeCommand(Kernels, Kernel, Command = False, verbose = True, quiet = False):
  try:
    if checkDirectory(builtins.SrcDir + "/" + Kernels[Kernel]['type']):
      if quiet:
        quiet = " --no-print-directory -s"
      else:
        quiet = ""
      if 'version_prefix' in Kernels[Kernel]:
        extraversion="EXTRAVERSION=-" + Kernels[Kernel]['version_prefix'].lower() + Kernel.lower()
      else:
        extraversion="EXTRAVERSION=-" + Kernel.lower()
      if Command:
        print("Executing make " + Command + " for kernel " + Kernel + " (" + Kernels[Kernel]['type'] + ")")
        return(runCommand("CC=arm-linux-gnueabihf-gcc KBUILD_DEBARCH=armhf /usr/bin/dpkg-architecture --host-type arm-linux-gnueabihf --command /usr/bin/make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- " + extraversion + " -j" + builtins.Threads + quiet +" -C " + builtins.SrcDir + "/" + Kernels[Kernel]['type'] + " " + Command, verbose))
      else:
        print("Executing make for kernel " + Kernel + " (" + Kernels[Kernel]['type'] + ")")
        return(runCommand("CC=arm-linux-gnueabihf-gcc KBUILD_DEBARCH=armhf /usr/bin/dpkg-architecture --host-type arm-linux-gnueabihf --command /usr/bin/make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- " + extraversion + " -j" + builtins.Threads + quiet +" -C " + builtins.SrcDir + "/" + Kernels[Kernel]['type'], verbose))
  except subprocess.CalledProcessError as e:
    return [e.returncode, e.output]
  except SystemExit:  
    pass
  except:
    logging.exception("Caught Exception")
    sys.exit(os.EX_SOFTWARE)

# Do a distclean in the kernel sources.
def kernelClean(Kernels, Kernel):
  try:
    print("Cleaning sources for kernel " + Kernel + " (" + Kernels[Kernel]['type'] + ")")
    return(makeCommand(Kernels, Kernel, "distclean"))
  except SystemExit:
    pass
  except:
    logging.exception("Caught Exception")
    sys.exit(os.EX_SOFTWARE)

# Configure the kernel.
def kernelConfig(Kernels, Kernel):
  try:
    kernelcfg = False
    if 'config' in Kernels[Kernel]:
      if checkFile(builtins.WorkDir + "/" + Kernels[Kernel]['config']):
        kernelcfg = Kernels[Kernel]['config']
    else:
      if checkFile(builtins.WorkDir + "/armStrap_" + Kernel + "_defconfig"):
        kernelcfg = "armStrap_" + Kernel + "_defconfig"
    if kernelcfg:
       shutil.copy(builtins.WorkDir + "/" + kernelcfg, builtins.SrcDir + "/" + Kernels[Kernel]['type'] + "/arch/arm/configs/")
    else:
      kernelcfg = Kernels[Kernel]['cpu'] + "_defconfig"
    print("Configuring kernel " + Kernel + " using " + kernelcfg)
    return(makeCommand(Kernels, Kernel, kernelcfg))
  except SystemExit:
    pass
  except:
    logging.exception("Caught Exception")
    sys.exit(os.EX_SOFTWARE)
    
# Modify the default debian packager to include a version in the firmware and libc package.
def patchBuildScript(Kernels, Kernel):
  try:
    if checkFile(builtins.SrcDir + "/" + Kernels[Kernel]['type'] + "/scripts/package/builddeb.armstrap_patched"):
      return([0, ""])
      os.remove(builtins.SrcDir + "/" + Kernels[Kernel]['type'] + "/scripts/package/builddeb.armstrap_patched")
    shutil.copy(builtins.SrcDir + "/" + Kernels[Kernel]['type'] + "/scripts/package/builddeb", builtins.SrcDir + "/" + Kernels[Kernel]['type'] + "/scripts/package/builddeb.armstrap_patched")
    result = runCommand("/bin/sed -i 's/^libc_headers_packagename=linux-libc-dev.*/libc_headers_packagename=linux-libc-dev-$version/' " +  builtins.SrcDir + "/" + Kernels[Kernel]['type'] + "/scripts/package/builddeb", verbose = False)
    if result[0] != 0:
      return(result)
    result = runCommand("/bin/sed -i 's/^fwpackagename=linux-firmware-image.*/fwpackagename=linux-firmware-image-$version/' " +  builtins.SrcDir + "/" + Kernels[Kernel]['type'] + "/scripts/package/builddeb", verbose = False)
    if result[0] != 0:
      return(result)
    return([0, ""])
  except SystemExit:
    pass
  except:
    logging.exception("Caught Exception")
    sys.exit(os.EX_SOFTWARE)

# Restore the default debian packager.
def restoreBuildScript(Kernels, Kernel):
  try:
    if checkFile(builtins.SrcDir + "/" + Kernels[Kernel]['type'] + "/scripts/package/builddeb.armstrap_patched"):
      os.remove(builtins.SrcDir + "/" + Kernels[Kernel]['type'] + "/scripts/package/builddeb")
      shutil.copy(builtins.SrcDir + "/" + Kernels[Kernel]['type'] + "/scripts/package/builddeb.armstrap_patched", builtins.SrcDir + "/" + Kernels[Kernel]['type'] + "/scripts/package/builddeb")
      os.remove(builtins.SrcDir + "/" + Kernels[Kernel]['type'] + "/scripts/package/builddeb.armstrap_patched")
    return([0, ""])
  except SystemExit:
    pass
  except:
    logging.exception("Caught Exception")
    sys.exit(os.EX_SOFTWARE)

# Get the kernel version
def kernelVersion(Kernels, Kernel):
  try:
    kv = makeCommand(Kernels, Kernel, "kernelrelease", Verbose = False, quiet = True)
    if len(kv) > 1:
      return(kv[1])
    return(False)
  except SystemExit:
    pass
  except:
    logging.exception("Caught Exception")
    sys.exit(os.EX_SOFTWARE)

# Build virtual packages.
def makeVirtualPackages(Kernels, Kernel):
  try:
    if 'version_prefix' in Kernels[Kernel]:
      version=Kernels[Kernel]['version_prefix'].lower() + Kernel.lower()
    else:
      version=Kernel.lower()
    print(builtins.WorkDir + "/mkvirtual -t " + builtins.WorkDir + " -s " + builtins.WorkDir + " -b " + builtins.SrcURL + " -h armhf -k " + version + " -d " + builtins.SrcDir)
    return(runCommand( builtins.WorkDir + "/mkvirtual -t " + builtins.WorkDir + " -s " + builtins.WorkDir + " -b " + builtins.SrcURL + " -h arm-linux-gnueabihf -k " + version + " -d " + builtins.SrcDir + "/", verbose = True))
  except SystemExit:
    pass
  except:
    logging.exception("Caught Exception")
    sys.exit(os.EX_SOFTWARE)
      
# Clone / Update and Build kernel Packages.
def buildKernel(Kernels, Kernel):
  try:
    #
    # Clean and clone / pull
    #
    
    log = "#\n# Kernel build for " + Kernel + " started at " + time.strftime("%c") + ".\n#\n\n"
    print("Kernel build for " + Kernel + " started at " + time.strftime("%c") + ".")
    
    log = log + "\n#\n# kernelClean\n#\n\n"
    result = kernelClean(Kernels, Kernel)
    if len(result) > 1:
      log = log + result[1]
      if  result[0] != 0:
        return([False, result[0], log])
    else:
      if result[0]:
        return([False, result[0], log])
      else:
        return([False, False, log])
    
    log = log + "\n#\n# gitClone\n#\n\n"
    result = gitClone(Kernels, Kernel)
    if len(result) > 1:
      log = log + result[1]
      if  result[0] != 0:
        return([False, result[0], log])
    else:
      if result[0]:
        return([False, result[0], log])
      else:
        return([False, False, log])
    
    log = log + "\n#\n# gitBranch\n#\n\n"
    result = gitBranch(Kernels, Kernel)
    if len(result) > 1:
      log = log + result[1]
      if  result[0] != 0:
        return([False, result[0], log])
    else:
      if result[0]:
        return([False, result[0], log])
      else:
        return([False, False, log])
    
    log = log + "\n#\n# gitReset\n#\n\n"
    result = gitReset(Kernels, Kernel)
    if len(result) > 1:
      log = log + result[1]
      if  result[0] != 0:
        return([False, result[0], log])
    else:
      if result[0]:
        return([False, result[0], log])
      else:
        return([False, False, log])
    
    log = log + "\n#\n# gitUpdate\n#\n\n"
    result = gitUpdate(Kernels, Kernel)
    if len(result) > 1:
      log = log + result[1]
      if  result[0] != 0:
        return([False, result[0], log])
    else:
      if result[0]:
        return([False, result[0], log])
      else:
        return([False, False, log])
    
    #
    # Build the Kernel packages
    #
    
    log = log + "\n#\n# kernelClean\n#\n\n"
    result = kernelClean(Kernels, Kernel)
    if len(result) > 1:
      log = log + result[1]
      if  result[0] != 0:
        return([False, result[0], log])
    else:
      if result[0]:
        return([False, result[0], log])
      else:
        return([False, False, log])
    
    log = log + "\n#\n# kernelConfig\n#\n\n"
    result = kernelConfig(Kernels, Kernel)
    if len(result) > 1:
      log = log + result[1]
      if  result[0] != 0:
        return([False, result[0], log])
    else:
      if result[0]:
        return([False, result[0], log])
      else:
        return([False, False, log])
    
    log = log + "\n#\n# patchBuildScript\n#\n\n"
    result = patchBuildScript(Kernels, Kernel)
    if len(result) > 1:
      log = log + result[1]
      if  result[0] != 0:
        return([False, result[0], log])
    else:
      if result[0]:
        return([False, result[0], log])
      else:
        return([False, False, log])    
    
    log = log + "\n#\n# makeCommand deb-pkg\n#\n\n"
    result = makeCommand(Kernels, Kernel, "deb-pkg")
    if len(result) > 1:
      log = log + result[1]
      if  result[0] != 0:
        return([False, result[0], log])
    else:
      if result[0]:
        return([False, result[0], log])
      else:
        return([False, False, log])
    
    log = log + "\n#\n# restoreBuildScript\n#\n\n"
    result = restoreBuildScript(Kernels, Kernel)
    if len(result) > 1:
      log = log + result[1]
      if  result[0] != 0:
        return([False, result[0], log])
    else:
      if result[0]:
        return([False, result[0], log])
      else:
        return([False, False, log])
    
    #
    # Build the virtual packages
    #
    log = log + "\n#\n# makeVirtualPackages\n#\n\n"
    result = makeVirtualPackages(Kernels, Kernel)
    if len(result) > 1:
      log = log + result[1]
      if  result[0] != 0:
        return([False, result[0], log])
    else:
      if result[0]:
        return([False, result[0], log])
      else:
        return([False, False, log])
    
    #
    # Make sure our package directory exist and move
    # packages there.
    #
    log = log + "\n#\n# makeDirectory\n#\n\n"
    if not makeDirectory(builtins.PkgDir + "/" + Kernel):
      return(False, False, log)
    
    log = log + "\n#\n# movePackages\n#\n\n"
    packages = glob.glob(builtins.SrcDir + "/*.deb")
    for package in packages:
      log = log +"Moving " + package + " to " + builtins.PkgDir + "/" + Kernel + "\n"
      print("Moving " + package + " to " + builtins.WorkDir + "/packages/" + Kernel)
      shutil.move(package, builtins.WorkDir + "/packages/" + Kernel)
      
    packages = glob.glob(builtins.WorkDir + "/*.deb")
    for package in packages:
      log = log +"Moving " + package + " to " + builtins.PkgDir + "/" + Kernel + "\n"
      print("Moving " + package + " to " + builtins.WorkDir + "/packages/" + Kernel)
      shutil.move(package, builtins.WorkDir + "/packages/" + Kernel)

    log = log + "#\n# Kernel build for " + Kernel + " ended at " + time.strftime("%c") + ".\n#\n\n"
    print("Kernel build for " + Kernel + " ended at " + time.strftime("%c") + ".")
      
    #
    # Write the build log to a file
    #
    
    f = open(builtins.WorkDir + "/packages/" + Kernel + ".log", 'w')
    f.write(log)
    f.close()
    
    return([True, 0, log])
  except SystemExit:
    pass
  except:
    logging.exception("Caught Exception")
    sys.exit(os.EX_SOFTWARE)

# Main program
def main():
  version = "1.01"
  WorkDir = builtins.WorkDir = os.getcwd()
  Config = builtins.Config = WorkDir + "/armStrap-Config.ini"
  Kernels = builtins.Kernels = WorkDir + "/armStrap-Kernels.ini"
  SrcDir = builtins.SrcDir = WorkDir + "/src"
  PkgDir = builtins.PkgDir = WorkDir + "/packages"
  SrcURL = builtins.SrcURL = "https://github.com/armStrapTools"
  Threads = builtins.Threads = "12"
  args = sys.argv[1:]
    
  parser = argparse.ArgumentParser(description=os.path.basename(sys.argv[0]) +" version " + version + ", (C) 2016 Eddy Beaupré", epilog="See " + builtins.SrcURL + " for more informations.", formatter_class=argparse.ArgumentDefaultsHelpFormatter)
  parser.add_argument("-c", "--config", help="Specify configuration file", action="store", default = builtins.Config, metavar=('FILE'))
  parser.add_argument("-k", "--kernels", help="Specify kernels configuration file", action="store", default = builtins.Kernels, metavar=('FILE'))
  parser.add_argument("-w", "--workdir", help="Specify work directory", action="store", default = builtins.WorkDir, metavar=('DIRECTORY'))
  parser.add_argument("-s", "--srcdir", help="Specify sources directory", action="store", default = builtins.SrcDir, metavar=('DIRECTORY'))
  parser.add_argument("-p", "--pkgdir",  help="Specify package directory", action="store", default = builtins.PkgDir, metavar=('DIRECTORY'))
  parser.add_argument("-t", "--threads", help="Specify number of threads", action="store", default = builtins.Threads, metavar=('DIRECTORY'))
  parser.add_argument("-v", "--version", action='version', version = os.path.basename(sys.argv[0]) + " version " + version)
  args = parser.parse_args()
  
  if args.config != Config:
    if checkFile(args.config):
      builtins.Config = args.config
  
  if checkFile(builtins.Config):
    config = readConfig(builtins.Config)
    if 'KernelsConfig' in config['armstrap-kernels']:
      builtins.Kernels = config['armstrap-kernels']['KernelsConfig']
    if 'SourcesDirectory' in config['armstrap-kernels']:
      builtins.SrcDir = config['armstrap-kernels']['SourcesDirectory']
    if 'WorkDirectory' in config['armstrap-kernels']:
      builtins.WorkDir = config['armstrap-kernels']['WorkDirectory']
    if 'PackagesDirectory' in config['armstrap-kernels']:
      builtins.PkgDir = config['armstrap-kernels']['PackagesDirectory']
    if 'MakeThreads' in config['armstrap-kernels']:
      builtins.Threads = config['armstrap-kernels']['MakeThreads']
  
  if args.workdir != WorkDir:
    builtins.WorkDir = args.workdir
  
  if args.srcdir != SrcDir:
    builtins.SrcDir = args.srcdir
  
  if args.kernels != Kernels:
    builtins.Kernels = args.kernels
    
  if args.pkgdir != PkgDir:
    builtins.PkgDir = args.pkgdir
  
  if args.threads != Threads:
    builtins.Threads = args.threads
  
  print("Builder Configuration : " + builtins.Config)
  print("Kernel COnfigurations : " + builtins.Kernels)
  print("    Sources Directory : " + builtins.SrcDir)
  print("   Packages Directory : " + builtins.PkgDir)
  print("       Work Directory : " + builtins.WorkDir)
  print("    Number of Threads : " + builtins.Threads)
  
  sys.exit(0)
  
  Kernels=readConfig(builtins.Kernels)
  
  if not Kernels:
    print("Config file not found")
    sys.exit(os.EX_SOFTWARE)

  if not checkDirectory(builtins.WorkDir):
    print("Work directory not found.")
    sys.exit(os.EX_SOFTWARE)

  if not checkDirectory(builtins.SrcDir):
    print("Source directory not found.")
    sys.exit(os.EX_SOFTWARE)
  
  for Kernel in Kernels.sections():
    result = buildKernel(Kernels, Kernel)
    if len(result) >= 3:
      if result[0]:
        print("Success")
      else:
        print("Failure : %d" % result[1])
    else:
      print("General Failure")
  
# Main body
if __name__ == '__main__':
  syslog.openlog(logoption=syslog.LOG_PID, facility=syslog.LOG_SYSLOG)
  syslogger = SysLogHandler(address='/dev/log')
  syslogger.setFormatter(logging.Formatter('%(filename)s[%(process)d] %(levelname)s: %(message)s'))
  logging.getLogger().addHandler(syslogger)
  
  main()
